(function($) {
    $(document).ready(function() {
      // Start the force-directed graph
      var w = $(window).innerWidth() - $("#leftPane").width() - 20;
      var h = $(window).innerHeight() - 18;
  
      var graph = new Graph("stageHolder", { width: w, height: h });
      hasChanged = false; // Can't have "var" - must be global
      var image = null;
      var lastRawText = "";
      var lastDraw = 0;
  
      function drawMindMap(firstLoad) {
        // Throttle redraw
        if (+new Date() - lastDraw < 1000) return;
        lastDraw = +new Date();
  
        graph.execute($("#textArea").val(), firstLoad);
  
        return false;
      }
  
      /** Setup a textarea with TAB & ENTER support ***/
      $("#textArea").keydown(function(e) {
        if (e.which == 9 || e.which == 13) {
          e.preventDefault();
          var selStart = this.selectionStart; //<- Works for all browsers except IE8
          var selEnd = this.selectionEnd;
          var txt = $(this).val();
          var prevBreak = txt.lastIndexOf("\n", selStart - 1); // Last line break before the cursor position
        }
  
        /*** TAB pressed - Tabbing with support for multiple line indenting and outdenting! ***/
        if (e.which == 9) {
          if (selStart <= selEnd) {
            lastBreak = txt.indexOf("\n", selEnd - 1);
            if (lastBreak < selEnd) lastBreak = selEnd;
  
            var linesToIndent = txt.substring(prevBreak + 1, lastBreak).split("\n");
            nbr = 0;
  
            if (e.shiftKey) {
              // OUTDENT
              linesToIndent.forEach(function(t, i) {
                if (t.charAt(0) == "	") {
                  linesToIndent[i] = t.substring(1, t.length); // Remove 1 leading tab
                  nbr++;
                }
              });
              var newString = linesToIndent.join("\n");
            } else {
              // INDENT
              var newString = "	" + linesToIndent.join("\n	");
              nbr = linesToIndent.length;
            }
            $(this).val(
              txt.substring(0, prevBreak + 1) + newString + txt.substring(lastBreak, txt.length)
            ); // Remove a tab
            this.selectionStart = e.shiftKey
              ? selStart - Math.min(1, nbr)
              : selStart + Math.min(1, nbr);
            this.selectionEnd = e.shiftKey ? selEnd - nbr : selEnd + nbr;
          }
        } else if (e.which == 13) {
          /*** ENTER pressed ***/
          if (e.ctrlKey) return drawMindMap(); // Command + Enter = Draw mindmap!
  
          // Get indent level (count number of tabs on previous line)
          var insert = "\n";
          for (var i = prevBreak; i <= selStart; i++) {
            var c = txt.charAt(i);
            if (c == "	") insert += "	";
            else if (c == " " || c == "\n") continue;
            else break;
          }
          if (insert == "\n" && prevBreak == -1) insert = "\n	"; // If we're at the first row and indenting, add a tab
          $(this).val(txt.substring(0, selStart) + insert + txt.substring(selStart, txt.length)); // Add a tab
          this.selectionStart = selStart + insert.length;
          this.selectionEnd = selStart + insert.length;
        }
      });
  
      // Resize stage after the last resize event
      var rtime = new Date(1, 1, 2000, 12, 00, 00);
      var timeout = false;
      var delta = 500;
      $(window).resize(function() {
        rtime = new Date();
        if (timeout === false) {
          timeout = true;
          setTimeout(resizeend, delta);
        }
      });
      function resizeend(fullScreen) {
        if (new Date() - rtime < delta) setTimeout(resizeend, delta);
        else {
          timeout = false;
          if (fullScreen) var w = $(window).innerWidth() - 20;
          else var w = $(window).innerWidth() - $("#leftPane").width() - 20;
          var h = $(window).innerHeight();
          graph.settings({ width: w, height: h });
        }
      }
      /** Indent / Outdent buttons **/
      $("#indent").click(function() {
        $("#textArea").trigger(jQuery.Event("keydown", { which: 9, shiftKey: false }));
      }); // Trigger tab
      $("#outdent").click(function() {
        $("#textArea").trigger(jQuery.Event("keydown", { which: 9, shiftKey: true }));
      }); // Trigger shift+tab
  
      /** LOCK & UNLOCK BUTTONS **/
      $("#lockAll").click(function() {
        graph.setNodeLocks(true);
        return false;
      });
      $("#unlockAll").click(function() {
        graph.setNodeLocks(false);
        return false;
      });
  
      // Set cursor at second line (new users will start push indent buttons... don't start with root node then)
      var setMarketAt = $("#textArea").val().indexOf("\n", $("#textArea").val().indexOf("\n") + 1);
      if (this.setSelectionRange) $("#textArea")[0].setSelectionRange(setMarketAt, setMarketAt);
  
      function save() {
        var obj = {};
        obj.text = $("#textArea").val();
        obj.font = graph.settings("font");
        obj.fontColor = graph.settings("fontColor");
        obj.fontSize = graph.settings("fontSize");
        obj.lineColor = graph.settings("lineColor");
        obj.lineWidth = graph.settings("lineWidth");
        obj.coloringMode = graph.settings("coloringMode");
        obj.bgcolors = JSON.stringify(graph.settings("bgcolors")); // We must stringify arrays.
        obj.positions = JSON.stringify(graph.exportPositions());
        obj.showLockIcons = null; /*Not implemented */
        obj.lockAfterMoving = graph.settings("lockAfterMoving") ? 1 : 0;
        obj.transform = JSON.stringify(graph.settings("transform"));
        obj.version = 0.4;
        //console.log( obj )
        return obj;
      }
  
      function open(obj) {
        // graph.stopForce();
        try {
          $("#textArea").val(obj.text);
          var data = {
            font: obj.font,
            fontColor: obj.fontColor,
            fontSize: parseInt(obj.fontSize),
            lineColor: obj.lineColor,
            lineWidth: parseFloat(obj.lineWidth),
            coloringMode: parseInt(obj.coloringMode),
            lockAfterMoving: parseInt(obj.lockAfterMoving),
            bgcolors: JSON.parse(obj.bgcolors),
            transform: JSON.parse(obj.transform)
          };
          $("#lockAfterMoving").prop("checked", data.lockAfterMoving == 1);
          if (data.coloringMode == 1) {
            $("#mode1").addClass("active");
            $("#mode2").removeClass("active");
          } else {
            $("#mode1").removeClass("active");
            $("#mode2").addClass("active");
          }
  
          graph.settings(data); // Load zoom settings and more
  
          // Important: Draw mind map here so the nodes in graph.nodes are created, before we set their positions
          drawMindMap(true);
          var pos = JSON.parse(obj.positions);
          graph.importPositions(pos, obj.version);
  
          hasChanged = false;
          lastRawText = obj.text;
          // $("#saveA").tooltip("hide");
          $(".saveMsg").hide();
        } catch (err) {
          alert("Sorry, there was an error while opening the mind map:\n" + err);
          drawMindMap();
        }
      }
  
      /*** AUTO-SAVING FUNCTIONS ***/
      var autoSaveTimer;
      function startAutoSaving() {}
  
      function stopAutoSaving() {
        clearTimer(autoSaveTimer);
      }
  
      /** FINALLY, DRAW ON LOAD 
              If we are opening a saved map - open that one. 
              Otherwise, open any map saved in cookie.
          */
      if (map) {
        drawMindMap(true);
      }
    });
  
    /******************************************
      Text 2 Mind Map
  
      Graph object.
      graph = { nodes:{}, links:{} }
      All links run from child node to parent (childNode.data.parent = parentNode)
   ****************************************/
  
    var Graph = function(div, settings) {
      // Setup parameters (Defaults)
      var p = {
        bgcolors: [
          "#3f3a3a",
          "#365C8E",
          "#31975A",
          "#C2583F",
          "#C2903F",
          "#9d9d9d",
          "#2365ba",
          "#16c75e",
          "#ff481c",
          "#ffa81c"
        ],
        coloringMode: 1,
        fontSize: 20,
        fontMinSize: 13,
        font: "Monaco",
        fontColor: "#ffffff",
        lineColor: "#abb2be",
        lineWidth: 3,
        scale: 1,
        lockAfterMoving: true,
        linkLength: 110,
        friction: 0.2,
        charge: 1600,
        width: 400,
        height: 400,
        gravity: 0.03
      };
      var p = $.extend({}, p, settings);
      var idLookup = []; // This is the lookup table for lineNbr -> Node index. Usage: idLookup[lineNbr=3] => Returns index for the node on lineNbr 3
      var textmarkerLookup = [];
      var posCount = [];
      var nextId = 0;
      var lastText = "";
      var branches = 0;
      var levels = 0;
      var offsetFromCenter;
      var dragged = false;
      var dragBackground = false;
      var force;
      var graph = { nodes: [], links: [] };
      var lastEvent = false;
      //var lastAlpha = 0.1;
  
      // Add the stage
      var layer = new Kinetic.Layer();
      var stage = new Kinetic.Stage({ container: div, width: p.width, height: p.height });
      stage.add(layer);
  
      var stageDiv = document.getElementById(div);
      var container = $("#" + div);
      container.bind("mousedown", function(e) {
        if (!dragged) {
          dragBackground = true;
          $(window).bind("mousemove", function(e) {
            if (!lastEvent) lastEvent = e;
            layer.move(e.pageX - lastEvent.pageX, e.pageY - lastEvent.pageY);
            layer.draw(); // Make sure the kineticjs is drawn - it seems like sometimes (very seldom) the layer is "stuck" and not moved if this is not provided
            lastEvent = e;
          });
        }
        e.preventDefault();
      });
      container.bind("mousemove", function(e) {
        if (dragged) {
          var point = transformPoint(e.pageX, e.pageY);
          dragged.x = point.x + offsetFromCenter.x; // Obs! We must set both .x and .px, but .x first!
          dragged.y = point.y + offsetFromCenter.y;
          dragged.px = dragged.x;
          dragged.py = dragged.y;
          if (force.alpha() < 0.02) force.alpha(0.025); // Force-layouter must be running when moving a node, we ensure this be calling resume() when alpha is low
          //force.tick();
        }
      });
      $(window).bind("mouseup", function(e) {
        if (dragBackground) {
          $(window).unbind("mousemove");
          dragBackground = false; // Must reset here, the mousedown/move events fire in strange order.
          // var offset = transformPoint(0, 0, true);
          // force.size([stage.getWidth() + 2*offset.x, stage.getHeight() + 2*offset.y])		// Used so that gravity pulls to the visible center, not layer center
        }
        if (dragged && dragged.data.parent !== false) dragged.fixed = p.lockAfterMoving;
        dragged = false;
        lastEvent = false;
      });
  
      function transformPoint(px, py, skipOffset) {
        var skipOffset = typeof skipOffset == "undefined" ? false : skipOffset;
        var m = layer.getTransform().m;
        if (skipOffset) return { x: (px - m[4]) / m[0], y: (py - m[5]) / m[3] };
        var offset = $("#" + div).offset();
        var x = (px - offset.left - m[4]) / m[0];
        var y = (py - offset.top - m[5]) / m[3];
        return { x: x, y: y };
      }
      that = {
        settings: function(setting, doRedraw) {
          doRedraw = typeof doRedraw == "undefined" ? true : doRedraw;
  
          if (typeof setting == "object") {
            p = $.extend({}, p, setting); // Merge new params into p.
  
            if (typeof setting.scale != "undefined") {
              // Scaling
              if (force) {
                var lastAlpha = force.alpha();
                force.stop();
              }
              var oldScale = layer.getScale().x;
              var newScale = setting.scale;
              layer.setScale(newScale);
              // p.gravity = Math.min(0.1, Math.max(0.02, 0.075*p.scale)); 	// p.gravity = [0.01 - 0.1] - decrement gravity when scale is small
              // force.gravity(p.gravity);
              layer.move(
                0.5 * p.width * (oldScale - newScale),
                0.5 * p.height * (oldScale - newScale)
              ); // Move so we zoom around center point
              if (force) force.alpha(lastAlpha);
            }
            if (typeof setting.height != "undefined" || typeof setting.width != "undefined") {
              // Resizing
              if (force) force.stop();
              stage.setHeight(p.height);
              stage.setWidth(p.width);
              if (force) force.alpha(0.02);
            }
            if (typeof setting.transform != "undefined") {
              // Transform
              var m = setting.transform;
              layer.move(m[4], m[5]); // Move
              layer.setScale(m[0], m[3]); // Scale
            }
            if (
              typeof setting.linkLength != "undefined" ||
              typeof setting.charge != "undefined" ||
              typeof setting.friction != "undefined" ||
              typeof setting.gravity != "undefined"
            ) {
              // Force directed params
              if (!force) return;
              force.linkDistance(p.linkLength);
              force.charge(-p.charge);
              force.friction(p.friction);
              force.gravity(p.gravity);
            }
          } else if (typeof setting == "string") {
            if (setting == "transform") return layer.getTransform().m;
            else return p[setting];
          }
          if (doRedraw) that.redrawAll();
        },
        stopForce: function() {
          if (force) force.stop();
        },
        execute: function(txt, firstLoad) {
          if (force) force.stop(); // The force calculations must be stopped since we will be messing with the node .x and .y positions
  
          that.text2mindmap(txt); // Convert text to graph. Stores a new graph with nodes and links into the variable graph.
  
          if (firstLoad !== true) {
            hasChanged = true;
            $(".saveMsg").show();
          }
          if (
            force // We are running, just update
          )
            force.start();
          else {
            force = d3.layout
              .force() // Start the force-directed layouter
              .linkDistance(function(d) {
                var additionalDistance =
                  d.target &&
                  d.target.ui &&
                  d.target.ui.children &&
                  d.target.ui.children[1].textWidth;
                var distance = p.linkLength;
                if (additionalDistance) {
                  distance = distance + (additionalDistance - 60) / 1.2;
                }
                return distance;
              })
              .charge(-p.charge)
              .friction(p.friction) // Default 0.9. If low, map is to unresponsive. If high, its to wobbly
              .theta(0.99) // Default 0.8
              .gravity(p.gravity) // Default 0.1
              .size([p.width, p.height])
              .nodes(graph.nodes) // Array of graph nodes
              .links(graph.links) // Array of graph links.
              .start()
              .on("tick", function() {
                var alpha = force.alpha();
                if (alpha < 0.011) {
                  force.alpha(alpha * 0.8);
                }
                that.redraw();
              });
          }
  
          /*
  
                  $("#stageHolder").hide();
                  $("#svgHolder").show();
  
                  setCookie();
  
                  var txt = that.text2tree( $("#textArea").val() );
                  var m = [20, 120, 20, 120]
                  var w = 1280 - m[1] - m[3]
                  var h = 800 - m[0] - m[2]
                  var i = 0
                  var root = txt;
                  var tree = null;
                  var vis = null;
                  root.x0 = h / 2;
                  root.y0 = 0;
  
                  var tree = d3.layout.tree().size([h, w]);
                  var diagonal = d3.svg.diagonal().projection(function(d) { return [d.y, d.x]; });
  
                  var vis = d3.select("#svgHolder").append("svg:svg")
                      .attr("width", w + m[1] + m[3])
                      .attr("height", h + m[0] + m[2])
                      .append("svg:g")
                      .attr("transform", "translate(" + m[3] + "," + m[0] + ")");
  
                  function toggleAll(d) {
                      if (d.children){
                          d.children.forEach(toggleAll);
                          toggle(d);
                      }
                  }	
  
                  // Initialize the display to show a few nodes.
                  root.children.forEach(toggleAll);
                  update(root);
  
                  function update(source){
                    var duration = d3.event && d3.event.altKey ? 5000 : 500;
  
                    // Compute the new tree layout.
                    var nodes = tree.nodes(root).reverse();
  
                    // Normalize for fixed-depth.
                    nodes.forEach(function(d) { d.y = d.depth * 180; });
  
                    // Update the nodes…
                    var node = vis.selectAll("g.node")
                          .data(nodes, function(d) { return d.id || (d.id = ++i); });
  
                    // Enter any new nodes at the parent's previous position.
                    var nodeEnter = node.enter().append("svg:g")
                          .attr("class", "node")
                          .attr("transform", function(d) { return "translate(" + source.y0 + "," + source.x0 + ")"; })
                          .on("click", function(d) { toggle(d); update(d); });
  
                    nodeEnter.append("svg:circle")
                          .attr("r", 1e-6)
                          .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });
  
                    nodeEnter.append("svg:text")
                          .attr("x", function(d) { return d.children || d._children ? -10 : 10; })
                          .attr("dy", ".35em")
                          .attr("text-anchor", function(d) { return d.children || d._children ? "end" : "start"; })
                          .text(function(d) { return d.name; })
                          .style("fill-opacity", 1e-6);
  
                    // Transition nodes to their new position.
                    var nodeUpdate = node.transition()
                          .duration(duration)
                          .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });
  
                    nodeUpdate.select("circle")
                          .attr("r", 4.5)
                          .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });
  
                    nodeUpdate.select("text")
                          .style("fill-opacity", 1);
  
                    // Transition exiting nodes to the parent's new position.
                    var nodeExit = node.exit().transition()
                          .duration(duration)
                          .attr("transform", function(d) { return "translate(" + source.y + "," + source.x + ")"; })
                          .remove();
  
                    nodeExit.select("circle")
                          .attr("r", 1e-6);
  
                    nodeExit.select("text")
                          .style("fill-opacity", 1e-6);
  
                    // Update the links…
                    var link = vis.selectAll("path.link")
                          .data(tree.links(nodes), function(d) { return d.target.id; });
  
                    // Enter any new links at the parent's previous position.
                    link.enter().insert("svg:path", "g")
                          .attr("class", "link")
                          .attr("d", function(d) {
                            var o = {x: source.x0, y: source.y0};
                            return diagonal({source: o, target: o});
                          })
                       .transition()
                          .duration(duration)
                          .attr("d", diagonal);
  
                    // Transition links to their new position.
                    link.transition()
                          .duration(duration)
                          .attr("d", diagonal);
  
                    // Transition exiting nodes to the parent's new position.
                    link.exit().transition()
                          .duration(duration)
                          .attr("d", function(d) {
                            var o = {x: source.x, y: source.y};
                            return diagonal({source: o, target: o});
                          })
                          .remove();
  
                    // Stash the old positions for transition.
                    nodes.forEach(function(d) {
                       d.x0 = d.x;
                       d.y0 = d.y;
                    });
                  }
  
                  // Toggle children.
                  function toggle(d) {
                    if( d.children ) {
                       d._children = d.children;
                       d.children = null;
                    } else {
                       d.children = d._children;
                       d._children = null;
                    }
                  }
                  */
        },
        getImage: function(callbackFn, scaling) {
          force.stop(); // Don't move right now
          var box = that.getBoundingBox(20);
          var targetW = 2736; // This is 11.3 inches at 240 DPI (a bit smaller than a fullsize A4 landscape; width 11.7 inches)
          var targetH = 1889; // This is 7.87 inches at 240 DPI (a bit smaller than a fullsize A4 landscape; height 8.27 inches)
          if (scaling == 1) var scale = 1;
          else
            var scale =
              targetW / box.width > targetH / box.height ? targetH / box.height : targetW / box.width;
  
          // Add a hidden stage
          var layer2 = layer.clone();
          var s = layer.getScale().x;
  
          var move1 = transformPoint(0, 0, true);
          layer2.move(move1.x * s, move1.y * s); // This resets any layer shifting (dragging background) that may have been done.
          layer2.move(-box.left, -box.top); // Move the layer so that the box is positioned at 0, 0 on stage coord.
          layer2.setScale(1); // Set scale = 1 so any previous scaling is not disturbing
  
          var stage2 = new Kinetic.Stage({
            container: "hiddenStage",
            width: box.width * scale, // Set the stage size to the bounding box - this way only the bounding box will take up the whole stage
            height: box.height * scale
          });
          stage2.add(layer2);
          stage2.setScale(scale);
          layer2.draw();
          that.fillLayerBackground(layer2, "#FFFFFF");
  
          stage2.toDataURL({
            mimeType: "image/jpeg",
            quality: 1.0,
            callback: function(dataUrl) {
              callbackFn(dataUrl);
              layer2.remove();
              stage2.remove();
            }
          });
        },
        computeStaticLayout: function(iterations) {
          force.start();
          for (var i = 0; i < iterations; i++) force.tick();
          force.stop();
        },
        fillLayerBackground: function(layer, color) {
          // Fill canvas with a white background. Valid until next layer.draw(). See http://www.mikechambers.com/blog/2011/01/31/
          var canvas = layer.getCanvas();
          var ctx = layer.getContext();
          ctx.save();
          ctx.globalCompositeOperation = "destination-over"; // Fill behind current content
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.fillStyle = "#FFFFFF";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.restore();
        },
        clear: function() {
          layer.removeChildren();
          graph.nodes = graph = { nodes: [], links: [] };
          force = false;
          lastText = "";
          that.execute("");
        },
        getBranches: function() {
          return branches;
        },
        getLevels: function() {
          return levels;
        },
        zoom: function(f) {
          // See if the map is scaled down. In previous versions (version 0.2), we scaled down using transform. If so, scale up with transform until scaleFactor is back at 1.
          if (f > 0 && layer.getScale().x < 1) {
            var newScale = Math.min(1, layer.getScale().x * 1.1);
            that.settings({ scale: newScale });
            return;
          }
          // Otherwise, use "fake scaling" - don't resize the canvas, just draw larger boxes...
          // Scaling factors, these are manually tuned. The goal is to have reasonable charge and linkLength at smaller distances
          var s_font = 0.8;
          var s_link = 0.7;
          var s_charge = 0.6;
          var s_friction = 0.01;
          var s_gravity = 0.015;
          var s_width = 0.8;
          var lev = 3; // Nbr of zooming levels allowed
          var maxFontSize = 23 / Math.pow(s_font, lev);
  
          // Limit max zoom in/out
          if (
            (f < 0 && p.fontSize <= p.fontMinSize) ||
            (f > 0 && p.fontSize >= maxFontSize) ||
            force == false
          )
            return;
  
          force.stop(); // Obs! We must stopped the graph calculations when we are messing with node positions
          var sign = f > 0 ? 1 : -1; // Move nodes close/further from origo
          graph.nodes.forEach(function(node) {
            node.x += 0.2 * (node.x - 0.5 * stage.getWidth()) * sign; // Zoom in/out 20%
            node.y += 0.2 * (node.y - 0.5 * stage.getHeight()) * sign;
            node.px = node.x;
            node.py = node.y;
          });
  
          if (f < 0) {
            // Zoom out
            var params = {
              fontSize: Math.max(p.fontMinSize, p.fontSize * s_font),
              linkLength: Math.max(20, p.linkLength * s_link),
              charge: Math.max(230, p.charge * s_charge),
              friction: Math.max(0.87, p.friction - s_friction),
              gravity: Math.max(0.025, p.gravity - s_gravity)
            };
          } else {
            // Zoom in
            var params = {
              fontSize: Math.min(23 / Math.pow(s_font, lev), p.fontSize / s_font),
              linkLength: Math.min(80 / Math.pow(s_link, lev), p.linkLength / s_link),
              charge: Math.min(1700 / Math.pow(s_charge, lev), p.charge / s_charge),
              friction: Math.min(0.9, p.friction + s_friction),
              gravity: Math.min(0.1, p.gravity + s_gravity)
            };
          }
          // //console.log(params)
          that.settings(params);
          force.start();
        },
        getBoundingBox: function(padding) {
          if (!padding) padding = 0;
          var box = { top: 9999, left: 9999, right: -9999, bottom: -9999 };
          var groups = layer.getChildren();
  
          for (var i = 0; i < groups.length; i++) {
            var g = groups[i];
            // //console.log(g);
            if (g.nodeType != "Group") continue;
            var w = 0.5 * g.children[0].attrs.width; // This is a hack - we assume there are layers -> groups -> and objects in the group with a width
            var h = 0.5 * g.children[0].attrs.height;
            // //console.log(g.attrs.x, w, h);
            if (g.attrs.x - w < box.left) box.left = g.attrs.x - w;
            if (g.attrs.y - h < box.top) box.top = g.attrs.y - h;
            if (g.attrs.x + w > box.right) box.right = g.attrs.x + w;
            if (g.attrs.y + h > box.bottom) box.bottom = g.attrs.y + h;
          }
          return {
            left: box.left - padding,
            right: box.right + padding,
            top: box.top - padding,
            bottom: box.bottom + padding,
            width: box.right - box.left + 2 * padding,
            height: box.bottom - box.top + 2 * padding
          };
        },
        addNode: function(pos, data) {
          // console.log("Adding new node", data.label, pos);
          if (force) force.stop(); // Must be still when adding nodes
          var node = { id: nextId++, fixed: data.fixed, x: data.x, y: data.y, data: data };
          graph.nodes.splice(pos, 0, node);
          return node;
        },
        addLink: function(source, target) {
          //console.log("Adding link from", source.data.label, "to", target.data.label);
          graph.links.push({
            source: source,
            target: target,
            data: { color: p.lineColor, weight: p.lineWidth, label: source.data.linkLabel }
          });
        },
        findNode: function(id) {
          for (var i = 0; i < graph.nodes.length; i++) {
            if (parseInt(graph.nodes[i].id) == parseInt(id)) return graph.nodes[i];
          }
          return false;
        },
        getLinksFrom: function(node) {
          var links = [];
          graph.links.forEach(function(link) {
            if (link.source.id == node.id) links.push(link);
          });
          return links;
        },
        getLinksTo: function(node) {
          var links = [];
          graph.links.forEach(function(link) {
            if (link.target.id == node.id) links.push(link);
          });
          return links;
        },
        isLinkedTo: function(from, to) {
          for (var i = 0; i < graph.links.length; i++) {
            if (graph.links[i].source.id == from.id && graph.links[i].target.id == to.id) return true;
          }
          return false;
        },
        removeLink: function(_link) {
          graph.links.forEach(function(link, i) {
            if (link == _link) {
              //console.log("Remove link from",link.source.data.label,link.target.data.label);
              if (link.ui) link.ui.remove();
              graph.links.splice(i, 1);
            }
          });
        },
        setNodeLocks: function(bool) {
          graph.nodes.forEach(function(node) {
            if (node.data.parent) node.fixed = bool;
          });
          if (bool == false) force.resume();
        },
        removeNode: function(pos) {
          if (force) force.stop(); // Must be still when adding nodes
          var node = graph.nodes[pos];
          if (!node) {
            console.log(
              "Could node find node with pos:" + pos + "\n\n" + JSON.stringify(graph.nodes)
            );
            return;
          }
  
          //console.log("Remove node at pos",pos, ". It has type", typeof node)
          that.getLinksFrom(node).forEach(function(link) {
            that.removeLink(link);
          });
          that.getLinksTo(node).forEach(function(link) {
            that.removeLink(link);
          });
          if (typeof node != "undefined") node.ui.remove();
          graph.nodes.splice(pos, 1); // Remove node
        },
        setStartPosition: function(node) {
          // Set a start position: We take the parent's position and position it's children in a circle below it
          if (node.data.parent == false) {
            // This is the root node, position it in the center.
            node.x = p.width * 0.5 - 380;
            node.y = p.height * 0.5 - 50;
            node.px = node.x;
            node.py = node.y;
            return node;
          }
  
          node.x = node.data.parent.x + 220; // Start at parent's position
          node.y = node.data.parent.y;
  
          var children = node.data.parent.data.children; // The weight is number of connections from a node (one of them is to the parent's parent, but nevermind)
          if (!children) children = 4;
  
          if (!posCount[node.data.parent.id]) posCount[node.data.parent.id] = 1;
          var count = posCount[node.data.parent.id]++;
  
          var angle = 135 + 270 / children * count;
          var linkLength = Math.max(60, 150 - node.data.level * 30);
          node.x += Math.round(linkLength * Math.cos(angle / 270 * 2 * Math.PI) + Math.random() * 10);
          node.y += Math.round(linkLength * Math.sin(angle / 270 * 2 * Math.PI) + Math.random() * 10);
          node.px = node.x;
          node.py = node.y;
          // console.log("Giving position", node.x, node.y, node.data.label, angle, children);
          return node;
        },
        redrawAll: function() {
          // Force redrawing all nodes & links. Called when changing settings
          graph.nodes.forEach(function(node) {
            node.data = that.setTheme(node.data);
            node.data.redraw = true;
          });
          graph.links.forEach(function(edge) {
            edge.data.color = p.lineColor;
            edge.data.weight = p.lineWidth;
            edge.data.redraw = true;
          });
          that.redraw();
        },
        redraw: function() {
          graph.links.forEach(function(link) {
            // Move existing line
            if (link.ui && !link.data.redraw) link.ui.setPoints([link.source, link.target]);
            else {
              // Draw new line
              if (link.ui) link.ui.remove();
              link.ui = that.newLine(link, link.source, link.target);
              layer.add(link.ui);
              link.ui.moveToBottom();
              link.data.redraw = false;
            }
          });
          // Draw text & boxes
          graph.nodes.forEach(function(node) {
            if (
              node.ui &&
              !node.data.redraw // Move existing node
            )
              node.ui.setPosition(node.x, node.y);
            else {
              // Draw new node
              if (node.ui) node.ui.remove();
              node.ui = that.newGroup(node);
              layer.add(node.ui);
              node.data.redraw = false;
              // console.log("Redraw UI for node");
            }
          });
          layer.draw();
        },
        newLine: function(link, n1, n2) {
          if (link.data.label) {
            var lineW = n2.x - n1.x;
            var lineH = n2.y - n1.y;
            var line = new Kinetic.Line({
              points: [{ x: 0, y: 0 }, { x: lineW, y: lineH }], // If not using a group, we can just do [n1, n2],
              stroke: link.data.color,
              strokeWidth: link.data.weight
            });
            var label = new Kinetic.Text({
              text: link.data.label,
              fontSize: 11,
              fontFamily: "Arial",
              fill: "#666",
              x: 0.5 * lineW - 50,
              y: 0.5 * lineH - 6,
              width: 100,
              align: "center"
            });
            var group = new Kinetic.Group({ x: n1.x, y: n1.y });
            group.add(line);
            group.add(label);
            group.setPoints = function(arr) {
              console.log("Move line", n1.data.label, "-", n2.data.label, n1.x, n2.x);
              var lineW = arr[1].x - arr[0].x;
              var lineH = arr[1].y - arr[0].y;
              line.setPoints([{ x: 0, y: 0 }, { x: lineW, y: lineH }]);
              label.setPosition(0.5 * lineW - 50, 0.5 * lineH - 6);
              group.setPosition(arr[0].x, arr[0].y);
            };
            return group;
          }
          // If not using a label
          return new Kinetic.Line({
            points: [n1, n2],
            stroke: link.data.color,
            strokeWidth: link.data.weight
          });
        },
        // newLine: function(link, n1, n2){		// Without label
        // 	return new Kinetic.Line({
        // 		points: [n1, n2],
        // 		stroke: link.data.color,
        // 		strokeWidth: link.data.weight
        // 	});
        // },
        newGroup: function(node) {
          var group = new Kinetic.Group({ x: node.x, y: node.y });
          var text = that.newText(node);
          var w = text.getWidth();
          var h = text.getHeight();
          text.setPosition(-0.5 * w, -0.5 * h);
          var rect = that.newRect(node, w, h);
          // console.log(node.data.label, rect)
          group.add(rect);
          group.add(text);
          // var mouseDown = function(e){
          // 	dragged = node;
          // 	dragged.fixed = true
          // 	var point = transformPoint(e.pageX, e.pageY);
          // 	offsetFromCenter = {x:dragged.x - point.x, y:dragged.y - point.y}
          // 	e.preventDefault(); // Prevents safari from showing text cursor
          // }
          group.on("mousedown", function(e) {
            dragged = node;
            dragged.fixed = true;
            var point = transformPoint(e.pageX, e.pageY);
            offsetFromCenter = { x: dragged.x - point.x, y: dragged.y - point.y };
            e.preventDefault(); // Prevents safari from showing text cursor
          });
  
          // group.on("touchstart", mouseDown);
          // Optimization experiment: If we work with many nodes on a zoomed out map, there is a lot to redraw - instead, lock nodes that are far apart from the dragged one
          // if(graph.nodes.length > 10){
          // 	graph.nodes.forEach(function(node2){
          // 		if(node2.data.branch != dragged.data.branch){
          // 			node2.data.orgFixed = node2.fixed;
          // 			node2.fixed = true;
          // 		}
          // 	})
          // }
          return group;
        },
        newRect: function(node, w, h) {
          return new Kinetic.Rect({
            // x: -0.5 * w - 1,
            // y: -0.5 * h,
            x: -0.5 * (w + 2) - 1,
            y: -0.5 * (h + 4),
            width: w + 4,
            height: h + 4,
            cornerRadius: 0,
            fill: node.data.color,
            opacity: 1,
            shadowColor: "#333", //node.data.shadow,
            shadowBlur: 2,
            shadowOffset: 2,
            shadowOpacity: 0.5
          });
        },
        newText: function(node) {
          var text = new Kinetic.Text({
            x: 0,
            y: 0,
            text: node.data.label,
            fontSize: node.data.fontSize,
            fontFamily: node.data.font,
            fill: node.data.fontColor,
            padding: Math.max(2, 3 - node.data.level),
            align: "center"
          });
          var max = that.maxTextWidth(node);
          if (text.getWidth() > max) text.setAttrs({ width: max });
          text.on("mouseover", function() {
            stageDiv.style.cursor = "pointer";
  
            var pos = graph.nodes.indexOf(node); // Line of the node the mouse is hovering over
            var textlines = $("#textArea").val().split(/\n/); // Break up the raw text on text lines
            var caretPos = -1;
            for (var i = 0; i <= pos; i++) {
              caretPos += textlines[i].length + 1;
            }
            if (caretPos != -1 && typeof caretPos != "undefined") {
              setCaretToPos($("#textArea")[0], caretPos);
              scrollToLine($("#textArea"), pos);
            }
          });
          text.on("mouseout", function() {
            node.data.redraw = true;
            if (!dragged) stageDiv.style.cursor = "move";
          });
          return text;
        },
        maxTextWidth: function(node) {
          var tmp = new Kinetic.Text({
            text: "MMMMMMMMMMMMMMMMMMMM",
            fontSize: node.data.fontSize,
            fontFamily: node.data.font
          });
          return tmp.getWidth();
        },
        findParent: function(textlines, startline, levelLookup) {
          // Find the first text line above "startline" with fewer indenting tabs.  Root node has no parent, i.e. parent = false
          if (startline == 0) return false;
  
          var currentLevel = levelLookup[startline];
          for (var lineNbr = startline; lineNbr >= 0; lineNbr--) {
            if (lineNbr > 0) {
              // Don't work with the root node.
              if (levelLookup[lineNbr] < currentLevel || lineNbr == 0) {
                // If the current line to test (lineNbr) has fewer tabs, or if we have looped all the way to the root node... (ensures there is a root node no matter how the text is tabbed/formatted)
                return lineNbr;
              }
            }
          }
          return 0;
        },
        hashCode: function(str) {
          var hash = 0;
          if (str.length == 0) return hash;
          for (i = 0; i < str.length; i++) {
            var ch = str.charCodeAt(i);
            hash = (hash << 5) - hash + ch;
          }
          return hash;
        },
        exportPositions: function() {
          var obj = [];
          graph.nodes.forEach(function(node, i) {
            var x = parseFloat(node.x).toFixed(2);
            var y = parseFloat(node.y).toFixed(2);
            obj.push({ i: i, x: x, y: y, f: node.fixed }); // Previous HTML5-versions (version 0.2-0.3) used: node.lineNbr = idLookup.indexOf(node.id) instead of node.i
            //console.log(obj[i])
          });
          return obj;
        },
        importPositions: function(obj, version) {
          if (force) force.stop(); // Stop graph calculations when messing with node positions (safety precaution...)
          // Backwards compability: In the first HTML5-version (version 0.2) there was a hashing function for calculating ids. Here we position them:
          if (parseFloat(version) <= 0.2) {
            var nbrNodesPerLevel = [];
            var graphLocationsById = [];
            graph.nodes.forEach(function(node) {
              if (!nbrNodesPerLevel[node.data.level]) nbrNodesPerLevel[node.data.level] = 1;
              else nbrNodesPerLevel[node.data.level]++; //nbrNodesPerLevel[node.data.level] + 1;
  
              var parentsOldId = node.data.parent ? node.data.parent.data.oldId : false;
              var graphLocation =
                graphLocationsById[parentsOldId] + "-" + nbrNodesPerLevel[node.data.level];
              var loc = parentsOldId ? graphLocationsById[parentsOldId] : undefined;
              var oldId = that.hashCode(
                node.data.label +
                  "_" +
                  loc +
                  "_" +
                  node.data.branch +
                  "_" +
                  node.data.level +
                  "_" +
                  parentsOldId
              );
              node.data.oldId = oldId;
              graphLocationsById[oldId] = graphLocation;
  
              var w = stage.getWidth();
              var h = stage.getHeight();
              for (var i = 0; i < obj.length; i++) {
                var saved = obj[i];
                // console.log(saved.id, node.data.oldId, saved.id == node.data.oldId)
                if (node.data.oldId == saved.id) {
                  node.x = 0.5 * w + saved.x / 22 * w; // 22 because the old window size was from -11 to 11 = total 22.
                  node.y = 0.5 * h + saved.y / 22 * h;
                  node.px = node.x;
                  node.py = node.y;
                  node.fixed = saved.locked; // The calculations for graphLocation are not really reliable, so we cheat and lock the nodes instead.;
                  break;
                }
              }
            });
          } else {
            // New version (0.3-0.4)
            for (var k = 0; k < obj.length; k++) {
              var saved = obj[k];
              var idx = version >= 0.4 ? saved.i : saved.lineNbr; // Version 0.3 used "lineNbr, 0.4 uses "i";
              var fixed = version >= 0.4 ? saved.f : saved.fixed; // Version 0.3 used "fixed", 0.4 uses "f";
              var node = graph.nodes[idx]; // Version 0.3 used: that.findNode( idLookup[saved.lineNbr] )
              if (node) {
                node.x = parseFloat(saved.x);
                node.y = parseFloat(saved.y);
                node.px = node.x;
                node.py = node.y;
                node.fixed = fixed; //true;
              }
              // console.log(idx, node.fixed, node.data.label, node.x)
            }
          }
          if (force) force.alpha(0.025); // We must stop graph calculations when messing with node positions
        },
        text2mindmap: function(rawtext) {
          // Split the text on line breaks (\n) and remove all empty lines.
          var text = rawtext.split(/\n/).filter(function(line) {
            return line.match(/\S/);
          });
          var text = text.join("\n");
  
          // Do a "diff" on the new text vs. the last submitted text. Uses jsdifflib: http://cemerick.github.io/jsdifflib/demo.html
          var newText = difflib.stringAsLines(text);
          var oldText = difflib.stringAsLines(lastText);
          var diff = new difflib.SequenceMatcher(oldText, newText).get_opcodes();
  
          var removed = 0;
          var added = 0;
  
          for (var idx = 0; idx < diff.length; idx++) {
            var code = diff[idx];
            var change = code[0];
            var b = code[1];
            var be = code[2];
            var n = code[3];
            var ne = code[4];
  
            var max = Math.max(be - b, ne - n);
            for (var i = 0; i < max; i++) {
              // Delete an old node if diff says "delete" or if diff says "replace" but there's no text to replace with (n==ne)
              if (change == "delete" || (change == "replace" && n == ne)) {
                var pos = b - removed + added;
                that.removeNode(pos);
                removed++;
                //console.log("Deleted", b, oldText[b].replace(/\t/g,""), "from array position", pos);
              } else if (
                change == "insert" ||
                (change == "replace" && b == be) ||
                (change == "replace" && !oldText[b])
              ) {
                // Insert a new node if diff says "insert" or if diff says "replace" but there's no text to replace (b==be)
                var pos = n; // n from diff
                var labels = getTextLabels(newText[pos]);
                var data = {
                  label: labels.label,
                  linkLabel: labels.linkLabel,
                  fixed: pos == 0,
                  children: 0
                };
                that.addNode(pos, data);
                added++;
                // console.log("Added", n, ":", newText[n].replace(/\t/g,""), "on array position", pos, data.fixed);
              } else if (change == "replace") {
                // Change an old node:
                var pos = b;
                var labels = getTextLabels(newText[n]);
                graph.nodes[pos].data.label = labels.label;
                graph.nodes[pos].data.linkLabel = labels.linkLabel;
                //console.log("Changed", b, ":", oldText[b].replace(/\t/g,""), "-->", newText[n].replace(/\t/g,""), b, be, n, ne);
              }
              // Update counters
              b = b < be ? b + 1 : b;
              n = n < ne ? n + 1 : n;
            }
          }
          // Set starting position, link to parent, and other parameters
          var levelLookup = [];
          var parentLookup = [];
          branches = 0; // Global var
          newText.forEach(function(textline, i) {
            levelLookup[i] = countLeadingTabs(textline);
            parentLookup[i] = that.findParent(text, i, levelLookup);
            if (levelLookup[i] > levels) levels++;
            //branchLookup[i] 	= (levelLookup[i] == 1) ? (++branches) : branches;
          });
          graph.nodes.forEach(function(node, i) {
            node.data.branch = levelLookup[i] == 1 ? ++branches : branches;
            node.data.level = levelLookup[i];
            node.data.parent = i == 0 ? false : graph.nodes[parentLookup[i]];
            node.data = that.setTheme(node.data);
            node.data.redraw = true;
  
            if (node.data.parent) {
              if (!that.isLinkedTo(node, node.data.parent)) {
                // Node has parent, but is not linked to parent yet.
                node.data.parent.data.children++;
                that.getLinksFrom(node).forEach(function(link) {
                  that.removeLink(link);
                }); // Remove any old link targetting this node (from any previous parent). See test #4.
                that.addLink(node, node.data.parent);
              }
            }
            // Check if link labels should be updated
            var link = that.getLinksFrom(node); // Should only be one...
            if ((link = link[0])) {
              if (link.data.label != node.data.linkLabel) {
                link.data.label = node.data.linkLabel;
                link.data.redraw = true;
              }
            }
          });
          // Now the children count is updated, so we set start positions here
          graph.nodes.forEach(function(node, i) {
            if (typeof node.x == "undefined") {
              node = that.setStartPosition(node);
            }
          });
          /* Debugging 
                  var str = "posInArray - Label - Parent's index ";
                  graph.nodes.forEach(function(node, i){
                      str += "\n" + i + " - " + node.data.label//+ node.data.parent.id;
                  });
                  console.log(str)
                  var str = "Links: source - target";
                  graph.links.forEach(function(link){
                      str += "\n" + link.source.data.label + " - " + link.target.data.label;
                  });
                  console.log(str)
                  */
          lastText = text;
          layer.draw();
        },
        // Set node color and font styles
        setTheme: function(data) {
          data.font = p.font;
          data.fontColor = p.fontColor ? p.fontColor : "#fff";
          data.fontSize = Math.max(p.fontMinSize, Math.round(p.fontSize * (1 - 0.17 * data.level)));
  
          if (p.coloringMode == 1)
            data.color =
              data.level >= p.bgcolors.length
                ? p.bgcolors[p.bgcolors.length - 1]
                : p.bgcolors[data.level];
          else
            data.color =
              data.branch >= p.bgcolors.length
                ? p.bgcolors[p.bgcolors.length - 1]
                : p.bgcolors[data.branch];
  
          if (typeof data.color == "undefined" || data.color == null) data.color = "#eeeeee"; // If coloring fails, fall back to some color so nodes are visible
          data.shadow = increase_brightness(data.color, 10);
          // data.colorMouseOver = increase_brightness(data.color, 30);
          // data.orgcolor = data.color;
          return data;
        },
        text2tree: function(rawtext) {
          text = rawtext.split(/\n/).filter(function(line) {
            return line.match(/\S/);
          }); // Split the text on line breaks (\n) and remove all empty lines .match().
          lastText = text;
          var tree;
          var lines = [];
          var levelLookup2 = [];
          $.each(text, function(lineNbr, textline) {
            levelLookup2[lineNbr] = countLeadingTabs(textline);
            var parentLineNbr = that.findParent(text, lineNbr, levelLookup2);
            var obj = { name: textline, children: [], lineNbr: lineNbr };
  
            if (lineNbr == 0) {
              tree = obj;
              lines[lineNbr] = obj;
            } else {
              lines[lineNbr] = obj;
              lines[parentLineNbr].children.push(obj);
            }
          });
          console.log(JSON.stringify(tree));
          return tree;
        }
      };
      return that;
    };
  
    function countLeadingTabs(str) {
      var nbr = 0;
      for (var i = 0; i < str.length; i++) {
        var c = str.charAt(i);
        if (c == "\t") nbr++;
        if (c != "\t" && c != " ") break;
      }
      return nbr;
    }
    function getTextLabels(text) {
      var obj = { label: "", linkLabel: false };
      text = text.trim();
      if (text.charAt(0) == "(") {
        var end = text.indexOf(")");
        if (end > 0) {
          obj.linkLabel = text.substr(1, end - 1);
          text = text.substring(end + 1).trim();
        }
      }
      obj.label = text;
      return obj;
    }
  
    // Array.forEach implementation for IE support..
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach
    if (!Array.prototype.forEach) {
      Array.prototype.forEach = function(callback, thisArg) {
        var T, k;
        if (this == null) {
          throw new TypeError(" this is null or not defined");
        }
        var O = Object(this);
        var len = O.length >>> 0; // Hack to convert O.length to a UInt32
        if ({}.toString.call(callback) != "[object Function]") {
          throw new TypeError(callback + " is not a function");
        }
        if (thisArg) {
          T = thisArg;
        }
        k = 0;
        while (k < len) {
          var kValue;
          if (k in O) {
            kValue = O[k];
            callback.call(T, kValue, k, O);
          }
          k++;
        }
      };
    }
  
    function setCaretToPos(input, pos) {
      setSelectionRange(input, pos, pos);
    }
    function setSelectionRange(input, selectionStart, selectionEnd) {
      if (input.setSelectionRange) {
        input.focus();
        input.setSelectionRange(selectionStart, selectionEnd);
      } else if (input.createTextRange) {
        var range = input.createTextRange();
        range.collapse(true);
        range.moveEnd("character", selectionEnd);
        range.moveStart("character", selectionStart);
        range.select();
      }
    }
    function scrollToLine($textarea, lineNumber) {
      var lineHeight = parseInt($textarea.css("line-height"));
      $textarea.scrollTop(lineNumber * lineHeight);
    }
    function increase_brightness(hex, percent) {
      // From: http://stackoverflow.com/questions/6443990/javascript-calculate-brighter-colour
      if (!hex) return; // Needed.
      hex = hex.replace(/^\s*#|\s*$/g, ""); // strip the leading # if it's there
      if (
        hex.length == 3 // convert 3 char codes --> 6, e.g. `E0F` --> `EE00FF`
      )
        hex = hex.replace(/(.)/g, "$1$1");
      var r = parseInt(hex.substr(0, 2), 16),
        g = parseInt(hex.substr(2, 2), 16),
        b = parseInt(hex.substr(4, 2), 16);
      return (
        "#" +
        (0 | ((1 << 8) + r + (256 - r) * percent / 100)).toString(16).substr(1) +
        (0 | ((1 << 8) + g + (256 - g) * percent / 100)).toString(16).substr(1) +
        (0 | ((1 << 8) + b + (256 - b) * percent / 100)).toString(16).substr(1)
      );
    }
  })(this.jQuery);
  
